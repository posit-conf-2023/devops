[
  {
    "objectID": "supplemental_materials/linux_exercises_files/linux_exercises.html",
    "href": "supplemental_materials/linux_exercises_files/linux_exercises.html",
    "title": "Linux exercises",
    "section": "",
    "text": "Login to play with docker using your docker hub credentials.\nAdd an instance to your session."
  },
  {
    "objectID": "supplemental_materials/linux_exercises_files/linux_exercises.html#setup",
    "href": "supplemental_materials/linux_exercises_files/linux_exercises.html#setup",
    "title": "Linux exercises",
    "section": "",
    "text": "Login to play with docker using your docker hub credentials.\nAdd an instance to your session."
  },
  {
    "objectID": "supplemental_materials/linux_exercises_files/linux_exercises.html#exercises",
    "href": "supplemental_materials/linux_exercises_files/linux_exercises.html#exercises",
    "title": "Linux exercises",
    "section": "Exercises",
    "text": "Exercises\n\nIdentify the user that you are logged in as.\nwhoami\nIdentify the linux distribution of your instance.\ncat /etc/*-release\nUse a single command to list the directories that are on the server and save the list as a txt file called directories.txt. Use cat to inspect the text file.\n$ ls -la &gt; directories.txt\nExplore the directories and files using cd, pwd, and ls -la. What is missing in this Linux server based on this article?\nAlpine images tend to be quite small without all the files and directories that we need. Lets pull in a more recent Ubuntu linux image. Go to Docker Hub and find the command to pull the latest version of Ubuntu linux. Make sure to use the Docker Official Image. (We will be going into much more depth later on how Docker images and containers work).\n# https://hub.docker.com/_/ubuntu/tags\ndocker pull ubutu:latest\n\n# use this command to see what images have been pulled\ndocker image list \nRun the container interactively with docker run -it ubuntu and re-run exercises 1 through 4 to inspect the new directory structure.\nChange directories to your root directory and then create 2 folders titles test1 and test2.\ncd ~\nmkdir test1 test2\nCreate a new user with the adduser command and enter in the requested information. Identify which groups currently exist in the system. Add your new user to the root group and then switch to that new user.\nadduser rika\n\n# Adding user `rika' ...\n# Adding new group `rika' (1000) ...\n# Adding new user `rika' (1000) with group `rika' ...\n# Creating home directory `/home/rika' ...\n# Copying files from `/etc/skel' ...\n# New password: \n# Retype new password: \n# passwd: password updated successfully\n# Changing the user information for rika\n# Enter the new value, or press ENTER for the default\n       #  Full Name []: Rika\n       #  Room Number []: \n       #  Work Phone []: \n       # Home Phone []: \n       # Other []: \n# Is the information correct? [Y/n] Y\n\ngroups\nusermod -aG root rika \nsu rika\n# use ctrl + d to exit back to root\n\ncd between the root directory and the home directory of your new user to understand how user home directories are stored in a linux file system.\n# the tilde is a shortcut to the home directory of the signed in user\ncd ~ \npwd\ncd /\npwd\nLets do some updates for our server.\n# update packages\napt-get update\n# add sudo which temporarily elevates privileges allowing users to complete sensitive tasks without logging in as the root user\napt-get install sudo\n# add your user to the sudoers group\nusermod -aG sudo rika"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DevOps for Data Scientists",
    "section": "",
    "text": ":spiral_calendar: September 17 and 18, 2023\n:alarm_clock: 09:00 - 17:00\n:hotel: ROOM TBD\n:writing_hand: pos.it/conf\n\n\n\n\n\n\n\nhttps://community.rstudio.com/t/devops-for-data-scientists-workshop-posit-conf-2023/171829\n\n\n\n\nSlides\nCode for Slides\nLab instructions\nLab example code\n\n\n\n\n\n\n\n\n\n\n\n\n\nADD INSTRUCTOR BIO\n\n This work is licensed under a Creative Commons Attribution 4.0 International License."
  },
  {
    "objectID": "index.html#pre-work",
    "href": "index.html#pre-work",
    "title": "DevOps for Data Scientists",
    "section": "",
    "text": "https://community.rstudio.com/t/devops-for-data-scientists-workshop-posit-conf-2023/171829"
  },
  {
    "objectID": "index.html#materials",
    "href": "index.html#materials",
    "title": "DevOps for Data Scientists",
    "section": "",
    "text": "Slides\nCode for Slides\nLab instructions\nLab example code"
  },
  {
    "objectID": "index.html#instructor",
    "href": "index.html#instructor",
    "title": "DevOps for Data Scientists",
    "section": "",
    "text": "ADD INSTRUCTOR BIO\n\n This work is licensed under a Creative Commons Attribution 4.0 International License."
  },
  {
    "objectID": "coursework_labs/02_lab_docker/Exercises.html",
    "href": "coursework_labs/02_lab_docker/Exercises.html",
    "title": "Lab: Docker",
    "section": "",
    "text": "Create a dockerhub username and password\n\nUsing your Docker hub username and password, login to https://labs.play-with-docker.com/\nClick + ADD NEW INSTANCE\nCongratulations! You are now in an Alpine Linux instance directly on your browser. Check this by running cat /etc/*-release in the command line interface.\n\n\n\n\n\n\n\nNote\n\n\n\nYour terminal should say something like [node1] (local) root@123.123.0.12 If it doesn’t refresh your screen or add another instance.\n\n\n\n\n\nThe basic docker run command takes this form:\ndocker run [OPTIONS] [IMAGE:TAG] [COMMAND] [ARG...]\nIn the below exercise we will practice running docker containers with different options or “flags.”\n\nCurrently we have no docker images downloaded. Confirm this with docker image ls -a.\n\nPull down a Dockerhub linux image. Confirm that the image is downloaded with the ls command.\n\ndocker pull ubuntu\ndocker image ls -a\n\nRun an interactive container with the bash shell attached. Run a few linux commands to explore your environment and then exit the container.\n\ndocker run -it ubuntu bash\nls\nwhoami\nhostname\n# exit the container with Ctrl+D or exit\nThis runs the container in the foreground so you are unable to access the command prompt for your original alpine server. For this reason interactive mode is often used for development and testing.\n\nRun the container in detached mode and then list all your containers.\n\ndocker run -d ubuntu\ndocker container ls -a\nYou should see that the ubuntu container was created and then exited. The container ID is shown with an exited status and the command line is still accessible.\nDetached containers run in the background, so the container keeps running until the application process exits (which is what happened here), or you stop the container. For this reason detached mode is often used for production purposes.\n\nRun an nginx web server in detached mode to see what happens when the process doesnt just exit. The image will be automatically pulled from Dockerhub if it is not found locally so there is no need to run docker pull first.\n\ndocker run -d -P --name nginx1 nginx:alpine\n\n# -P publishes network ports so you can send traffic into the container\n# --name gives the container a name so you can work with it in other commands\nClick on the port button at the top of your page and enter 32768.\n\nThis should bring you to the nginx server.\n\n\nExamine your container and then stop it.\n\n# check your running containers\ndocker container ls -a\n\n# you can also check your running processes\ndocker ps -a\n\n# stop the container using its name\ndocker container stop nginx1\n\nRun a container with a different linux distro and then automatically remove it. Add an echo command to confirm that the container has actually run.\n\ndocker run --rm debian echo \"hello world\"\nThis mode is usually used on foreground containers that perform short-term tasks such as tests or database backups. Since a container is ephemeral, once it is removed anything you may have downloaded or created in the container is also destroyed.\nCheck to see that the container was completely removed. You shouldnt see the debian container in the output at all.\ndocker container ls -a\n\n\n\nThe docker exec command is very similar to the docker run -it command. Both are very helpful for debugging containers as they allow you to jump inside your container instance. The exec command needs a running container to execute any command, whereas the -it flag starts a container and places you into a terminal in interactive mode. Use the docker exec command to execute a bash command in a running container. This can be used to execute any command within a running container.\ndocker exec requires two arguments - the container and the command you want to run.\ndocker exec [OPTIONS] CONTAINER [COMMAND] [ARG...]\n\nUse docker run -it to jump into an ubuntu container.\n\ndocker run -it -d ubuntu\nexit\n\nUse docker exec to run commands in a container\n\ndocker container ls -a # to get a container ID of a running container\ndocker exec -it CONTAINER_ID bash\nexit\ndocker exec CONTAINER_ID ls \n\nLets run a detached MySQL container and then check out some logs. The database requires a password to work.In production you should never pass credentials directly in your command but we will do it for testing purposes. (The forward slashes below allow you to use a new line for your code)\n\n docker container run -d --name mydb \\\n --name mydb \\\n -e MYSQL_ROOT_PASSWORD=my-secret-pw \\ \n mysql\n \ndocker container logs mydb\n\n\n\n\nPull two versions of the same image\n\ndocker pull httpd:alpine\ndocker pull httpd:latest\n\nInspect ports.\n\ndocker inspect  httpd:latest\ndocker inspect  httpd:alpine\n\nMap two different host ports to the same application port for the two containers.\n\ndocker run -d -p 81:80 --name httpd-latest httpd:latest\ndocker run -d -p 80:80 --name httpd-alpine httpd:alpine\ndocker ps\n\n\n\n\nStop your running containers with docker stop and return to your original command prompt.\nCreate a text file.\n\ntouch test.txt # create a text file\necho \"this is a test file\" &gt; test.txt # redirect string to the file\ncat test.txt # confirm that the echo command worked\n\nWe want to add this file from our host machine into a separate Ubuntu container.\n\npwd # to see where the test.txt file is located on your host machine\n\ndocker run -it -d -v /root:/data ubuntu # mount a shared volume to a folder in the container called \"data\"\n\ndocker exec -it CONTAINER_ID bash\n\nls # see what folders are in the container\n\ncd data # move to the newly created data directory\n\nls # confirm that the text file is there\nIn order to get data in or out of a container, you need to mount a shared volume (directory) between the container and host with the -v flag. You specify a host directory and a container directory separated by :. Anything in the volume will be available to both the host and the container at the file paths specified.\n\n\n\n\nExit out of your container from the previous exercise with exit and confirm that the container is still running. This container should have the new directory and text file.\nRun docker diff CONTAINER_ID to see the difference between the base image and the new container. You should see the new data folder,\nLogin to docker hub in your instance using docker login and enter your username and password.\nCommit the changed ubuntu image and give it a new name like ubuntu_text.\n\ndocker commit CONTAINER_ID ubuntu_text\ndocker image ls # to check the new image is available\n\nTag and push the image to dockerhub. Login to docker hub to see your saved and shareable image!\n\ndocker tag ubuntu_text docker_hub_username/ubuntu_text\ndocker push docker_hub_username/ubuntu_text\n\n\n\nBest practice is to create a Dockerfile so that any changes to your image can be documented.\n\nCreate a Dockerfile (no file extension needed)in your instance with touch Dockerfile and add the following to it.\n\ntouch Dockerfile\nvim Dockerfile\n# press i to enter insert mode\n\nFROM rocker/shiny:4.3.1\nCMD [\"/usr/bin/shiny-server\"]\n\n# press escape \n:wq # to save and exit\n\nBuild the image with docker build -t my_server . where my_server is the name of your new image\nRun your container with docker run -d -p 3838:3838 my_server\n\nthe -p flag maps a port from the host to a port in the container.\nthis gives us the ability to access the services running inside the container\nexample: `-p 8080:80` maps port 8080 on the host to port 80 in the container.\nin our code we use port 3838 because that is the port that Shiny Server uses by default.\n\nA port number will appear - click on it to access the home page of Shiny Server!\n\n\n\nYou should see something like this:\n\nWe want to change the home page and have it show an app of our choosing instead. Exec into your container and let’s find where the information for the home page is stored.\n\n# get the container ID or name \ndocker container ls \n\n# execute into the bash shell in your container\ndocker exec -it CONTAINER_ID bash \n\n# list your folders\nls \n\n#this will show you all the server executables for basic shell commands. See if you can find those you've used like touch\ncd usr/bin \nls\n\n# look at the code for the home page,. Notice where the sample \"It's Alive\" and \"Shiny Doc\" apps on the home page are being pulled from\ncd /srv/shiny-server \nls\ncat index.html \n\n# look at the configuration file for the server\ncd /etc/shiny-server\ncat shiny-server.conf \n\nLet’s delete the home page and the sample apps in the server.\n\nsudo rm /srv/shiny-server/index.html\nsudo rm -rf /srv/shiny-server/sample-apps\n# refresh your shiny server webpage\nNotice how the server home page now has a directory of the apps that live in /srv/shiny-server. Recall how the configuration file had directory_index turned on.\n\nLet’s create a basic shiny app and then rebuild our image. We will move our app to the server in our Dockerfile instead of on the fly in our run command.\n\nexit\ndocker container ls \ndocker container stop CONTAINER_IT \nmkdir apps\ncd apps\ntouch app.R\nvim app.R\n# press i to insert the following code\n\nlibrary(shiny)\n\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n\n    # Application title\n    titlePanel(\"Old Faithful Geyser Data\"),\n\n    # Sidebar with a slider input for number of bins \n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"bins\",\n                        \"Number of bins:\",\n                        min = 1,\n                        max = 50,\n                        value = 30)\n        ),\n\n        # Show a plot of the generated distribution\n        mainPanel(\n           plotOutput(\"distPlot\")\n        )\n    )\n)\n\n# Define server logic required to draw a histogram\nserver &lt;- function(input, output) {\n\n    output$distPlot &lt;- renderPlot({\n        # generate bins based on input$bins from ui.R\n        x    &lt;- faithful[, 2]\n        bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n\n        # draw the histogram with the specified number of bins\n        hist(x, breaks = bins, col = 'darkgray', border = 'white',\n             xlab = 'Waiting time to next eruption (in mins)',\n             main = 'Histogram of waiting times')\n    })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\n# press escape \n:wq to save \n\n##docker run -d -p 3838:3838 -v ./apps:/srv/shinyapps my_server # my_server is the name of the docker image that you built\n\nUpdate our Dockerfile\n\ncd /root\nvim Dockerfile\n# press i to insert code\n\nFROM rocker/shiny:4.3.1\n# comes preinstalled with a bunch of packages\n\nRUN apt-get update && apt-get install -y \\\n    libcurl4-gnutls-dev \\\n    libssl-dev\n\nRUN R -e \"install.packages(('palmerpenguins'), \\\n    repos = 'https://packagemanager.posit.co/cran/__linux__/jammy/latest')\"\n\nCOPY ./apps/* /srv/shiny-server/\n\nCMD [\"/usr/bin/shiny-server\"]\n\nRebuild the dockerfile with a new name\n\ndocker build -t new_app\n\nRun the container\n\ndocker run -d -p 3838:3838 new_app"
  },
  {
    "objectID": "coursework_labs/02_lab_docker/Exercises.html#goals",
    "href": "coursework_labs/02_lab_docker/Exercises.html#goals",
    "title": "Lab: Docker",
    "section": "",
    "text": "Create a dockerhub username and password\n\nUsing your Docker hub username and password, login to https://labs.play-with-docker.com/\nClick + ADD NEW INSTANCE\nCongratulations! You are now in an Alpine Linux instance directly on your browser. Check this by running cat /etc/*-release in the command line interface.\n\n\n\n\n\n\n\nNote\n\n\n\nYour terminal should say something like [node1] (local) root@123.123.0.12 If it doesn’t refresh your screen or add another instance.\n\n\n\n\n\nThe basic docker run command takes this form:\ndocker run [OPTIONS] [IMAGE:TAG] [COMMAND] [ARG...]\nIn the below exercise we will practice running docker containers with different options or “flags.”\n\nCurrently we have no docker images downloaded. Confirm this with docker image ls -a.\n\nPull down a Dockerhub linux image. Confirm that the image is downloaded with the ls command.\n\ndocker pull ubuntu\ndocker image ls -a\n\nRun an interactive container with the bash shell attached. Run a few linux commands to explore your environment and then exit the container.\n\ndocker run -it ubuntu bash\nls\nwhoami\nhostname\n# exit the container with Ctrl+D or exit\nThis runs the container in the foreground so you are unable to access the command prompt for your original alpine server. For this reason interactive mode is often used for development and testing.\n\nRun the container in detached mode and then list all your containers.\n\ndocker run -d ubuntu\ndocker container ls -a\nYou should see that the ubuntu container was created and then exited. The container ID is shown with an exited status and the command line is still accessible.\nDetached containers run in the background, so the container keeps running until the application process exits (which is what happened here), or you stop the container. For this reason detached mode is often used for production purposes.\n\nRun an nginx web server in detached mode to see what happens when the process doesnt just exit. The image will be automatically pulled from Dockerhub if it is not found locally so there is no need to run docker pull first.\n\ndocker run -d -P --name nginx1 nginx:alpine\n\n# -P publishes network ports so you can send traffic into the container\n# --name gives the container a name so you can work with it in other commands\nClick on the port button at the top of your page and enter 32768.\n\nThis should bring you to the nginx server.\n\n\nExamine your container and then stop it.\n\n# check your running containers\ndocker container ls -a\n\n# you can also check your running processes\ndocker ps -a\n\n# stop the container using its name\ndocker container stop nginx1\n\nRun a container with a different linux distro and then automatically remove it. Add an echo command to confirm that the container has actually run.\n\ndocker run --rm debian echo \"hello world\"\nThis mode is usually used on foreground containers that perform short-term tasks such as tests or database backups. Since a container is ephemeral, once it is removed anything you may have downloaded or created in the container is also destroyed.\nCheck to see that the container was completely removed. You shouldnt see the debian container in the output at all.\ndocker container ls -a\n\n\n\nThe docker exec command is very similar to the docker run -it command. Both are very helpful for debugging containers as they allow you to jump inside your container instance. The exec command needs a running container to execute any command, whereas the -it flag starts a container and places you into a terminal in interactive mode. Use the docker exec command to execute a bash command in a running container. This can be used to execute any command within a running container.\ndocker exec requires two arguments - the container and the command you want to run.\ndocker exec [OPTIONS] CONTAINER [COMMAND] [ARG...]\n\nUse docker run -it to jump into an ubuntu container.\n\ndocker run -it -d ubuntu\nexit\n\nUse docker exec to run commands in a container\n\ndocker container ls -a # to get a container ID of a running container\ndocker exec -it CONTAINER_ID bash\nexit\ndocker exec CONTAINER_ID ls \n\nLets run a detached MySQL container and then check out some logs. The database requires a password to work.In production you should never pass credentials directly in your command but we will do it for testing purposes. (The forward slashes below allow you to use a new line for your code)\n\n docker container run -d --name mydb \\\n --name mydb \\\n -e MYSQL_ROOT_PASSWORD=my-secret-pw \\ \n mysql\n \ndocker container logs mydb\n\n\n\n\nPull two versions of the same image\n\ndocker pull httpd:alpine\ndocker pull httpd:latest\n\nInspect ports.\n\ndocker inspect  httpd:latest\ndocker inspect  httpd:alpine\n\nMap two different host ports to the same application port for the two containers.\n\ndocker run -d -p 81:80 --name httpd-latest httpd:latest\ndocker run -d -p 80:80 --name httpd-alpine httpd:alpine\ndocker ps\n\n\n\n\nStop your running containers with docker stop and return to your original command prompt.\nCreate a text file.\n\ntouch test.txt # create a text file\necho \"this is a test file\" &gt; test.txt # redirect string to the file\ncat test.txt # confirm that the echo command worked\n\nWe want to add this file from our host machine into a separate Ubuntu container.\n\npwd # to see where the test.txt file is located on your host machine\n\ndocker run -it -d -v /root:/data ubuntu # mount a shared volume to a folder in the container called \"data\"\n\ndocker exec -it CONTAINER_ID bash\n\nls # see what folders are in the container\n\ncd data # move to the newly created data directory\n\nls # confirm that the text file is there\nIn order to get data in or out of a container, you need to mount a shared volume (directory) between the container and host with the -v flag. You specify a host directory and a container directory separated by :. Anything in the volume will be available to both the host and the container at the file paths specified.\n\n\n\n\nExit out of your container from the previous exercise with exit and confirm that the container is still running. This container should have the new directory and text file.\nRun docker diff CONTAINER_ID to see the difference between the base image and the new container. You should see the new data folder,\nLogin to docker hub in your instance using docker login and enter your username and password.\nCommit the changed ubuntu image and give it a new name like ubuntu_text.\n\ndocker commit CONTAINER_ID ubuntu_text\ndocker image ls # to check the new image is available\n\nTag and push the image to dockerhub. Login to docker hub to see your saved and shareable image!\n\ndocker tag ubuntu_text docker_hub_username/ubuntu_text\ndocker push docker_hub_username/ubuntu_text\n\n\n\nBest practice is to create a Dockerfile so that any changes to your image can be documented.\n\nCreate a Dockerfile (no file extension needed)in your instance with touch Dockerfile and add the following to it.\n\ntouch Dockerfile\nvim Dockerfile\n# press i to enter insert mode\n\nFROM rocker/shiny:4.3.1\nCMD [\"/usr/bin/shiny-server\"]\n\n# press escape \n:wq # to save and exit\n\nBuild the image with docker build -t my_server . where my_server is the name of your new image\nRun your container with docker run -d -p 3838:3838 my_server\n\nthe -p flag maps a port from the host to a port in the container.\nthis gives us the ability to access the services running inside the container\nexample: `-p 8080:80` maps port 8080 on the host to port 80 in the container.\nin our code we use port 3838 because that is the port that Shiny Server uses by default.\n\nA port number will appear - click on it to access the home page of Shiny Server!\n\n\n\nYou should see something like this:\n\nWe want to change the home page and have it show an app of our choosing instead. Exec into your container and let’s find where the information for the home page is stored.\n\n# get the container ID or name \ndocker container ls \n\n# execute into the bash shell in your container\ndocker exec -it CONTAINER_ID bash \n\n# list your folders\nls \n\n#this will show you all the server executables for basic shell commands. See if you can find those you've used like touch\ncd usr/bin \nls\n\n# look at the code for the home page,. Notice where the sample \"It's Alive\" and \"Shiny Doc\" apps on the home page are being pulled from\ncd /srv/shiny-server \nls\ncat index.html \n\n# look at the configuration file for the server\ncd /etc/shiny-server\ncat shiny-server.conf \n\nLet’s delete the home page and the sample apps in the server.\n\nsudo rm /srv/shiny-server/index.html\nsudo rm -rf /srv/shiny-server/sample-apps\n# refresh your shiny server webpage\nNotice how the server home page now has a directory of the apps that live in /srv/shiny-server. Recall how the configuration file had directory_index turned on.\n\nLet’s create a basic shiny app and then rebuild our image. We will move our app to the server in our Dockerfile instead of on the fly in our run command.\n\nexit\ndocker container ls \ndocker container stop CONTAINER_IT \nmkdir apps\ncd apps\ntouch app.R\nvim app.R\n# press i to insert the following code\n\nlibrary(shiny)\n\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n\n    # Application title\n    titlePanel(\"Old Faithful Geyser Data\"),\n\n    # Sidebar with a slider input for number of bins \n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"bins\",\n                        \"Number of bins:\",\n                        min = 1,\n                        max = 50,\n                        value = 30)\n        ),\n\n        # Show a plot of the generated distribution\n        mainPanel(\n           plotOutput(\"distPlot\")\n        )\n    )\n)\n\n# Define server logic required to draw a histogram\nserver &lt;- function(input, output) {\n\n    output$distPlot &lt;- renderPlot({\n        # generate bins based on input$bins from ui.R\n        x    &lt;- faithful[, 2]\n        bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n\n        # draw the histogram with the specified number of bins\n        hist(x, breaks = bins, col = 'darkgray', border = 'white',\n             xlab = 'Waiting time to next eruption (in mins)',\n             main = 'Histogram of waiting times')\n    })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\n# press escape \n:wq to save \n\n##docker run -d -p 3838:3838 -v ./apps:/srv/shinyapps my_server # my_server is the name of the docker image that you built\n\nUpdate our Dockerfile\n\ncd /root\nvim Dockerfile\n# press i to insert code\n\nFROM rocker/shiny:4.3.1\n# comes preinstalled with a bunch of packages\n\nRUN apt-get update && apt-get install -y \\\n    libcurl4-gnutls-dev \\\n    libssl-dev\n\nRUN R -e \"install.packages(('palmerpenguins'), \\\n    repos = 'https://packagemanager.posit.co/cran/__linux__/jammy/latest')\"\n\nCOPY ./apps/* /srv/shiny-server/\n\nCMD [\"/usr/bin/shiny-server\"]\n\nRebuild the dockerfile with a new name\n\ndocker build -t new_app\n\nRun the container\n\ndocker run -d -p 3838:3838 new_app"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html",
    "href": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html",
    "title": "Lab: Deploy Quarto with GHA",
    "section": "",
    "text": "To get familiar with how the renv package helps create reproducible environments for your R projects.\nTo get comfortable using the terminal for interacting with git and github.\nTo understand how to authenticate to github using SSH or HTTPS.\nTo practice writing and reading a yaml file.\nTo understand the basics of a quarto website.\nTo deploy a quarto site to Github Pages using Github Actions for Continuous Deployment. This will allow you to update your site every time you push a commit to git."
  },
  {
    "objectID": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html#goals",
    "href": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html#goals",
    "title": "Lab: Deploy Quarto with GHA",
    "section": "",
    "text": "To get familiar with how the renv package helps create reproducible environments for your R projects.\nTo get comfortable using the terminal for interacting with git and github.\nTo understand how to authenticate to github using SSH or HTTPS.\nTo practice writing and reading a yaml file.\nTo understand the basics of a quarto website.\nTo deploy a quarto site to Github Pages using Github Actions for Continuous Deployment. This will allow you to update your site every time you push a commit to git."
  },
  {
    "objectID": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html#setup",
    "href": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html#setup",
    "title": "Lab: Deploy Quarto with GHA",
    "section": "Setup",
    "text": "Setup\n\nTo setup your cloud-based development environment create an account using your email at http://rstd.io/class with code angry-beaver. Click on the Rstudio Workbench widget to start your environment.\nClick on + New Session to create a new Rstudio Pro session.\n\n\n\n\n\n\n\nNote\n\n\n\nYou can also set up your project in your local IDE but then you will need to install Quarto and other environment dependencies."
  },
  {
    "objectID": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html#part-1-create-a-local-quarto-website",
    "href": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html#part-1-create-a-local-quarto-website",
    "title": "Lab: Deploy Quarto with GHA",
    "section": "Part 1: Create a local Quarto website",
    "text": "Part 1: Create a local Quarto website\nQuarto is a multi-lingual open-source scientific and technical publishing system that lets you create documents, articles, blogs, websites, and more.\n\nOpen a session in your workbench environment. Give it a name.\nTo create a new website project within RStudio, click on File &gt; New Project &gt; New Directory &gt; Quarto Website and save it to a directory with a name.\n\n\n\n\n\n\n\nquarto site file structure\n\n\n\n\n\n_quarto.yml - project file\nabout.qmd - About page\nindex.qmd - Home page\nstyles.css - custom CSS\n_site - this will be created after you render your files\n\n\n\n\nPress render to see your new website! Or preview via terminal with quarto preview. Make sure that your web browser allows popups. This may take a few moments to install some required packages.\nCreate a repository on github but do not initialize it with a README, license, or gitignore files. This repo will host the files for the site that you will be deploying to Github Pages.\n\nName your repository username.github.io where username is your github username. If you already have this name in use, then name your repo quarto_website\n\nOpen the terminal tab in your Rstudio Workbench environment, cd into your project directory.\nInitialize a local git repository with git init.\nRename your master branch to main so that branch names are consistent across your github repo and your local git. You can use git branch to see what branches exist on your repo and switch between them using git checkout &lt;branch&gt;.\n\n# in your terminal\ngit branch -m master main\n\nConfigure your github information in the terminal. To set your global commit name and email address run the git config command with the --global option:\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"youremail@yourdomain.com\"\ngit config --global init.defaultBranch main\nOnce done, you can confirm that the information is set by running:\ngit config --list\nCreate a .gitignore file in your main directory. Add the following to the file and save:\n\n/.quarto/\n/_site/\n.Rproj.user\n.Rhistory"
  },
  {
    "objectID": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html#part-2-renv-workflow",
    "href": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html#part-2-renv-workflow",
    "title": "Lab: Deploy Quarto with GHA",
    "section": "Part 2: renv workflow",
    "text": "Part 2: renv workflow\n\nExercises:\n\nRun .libPaths() to see your library path\nRun lapply(.libPaths(), list.files) to see what is in your library directory\n\nInstall and initialize an renv workflow.\n\n\n\n\n\n\n\nrenv workflow\n\n\n\n\n\n\nInstall the renv package with install.packages(\"renv\")\nRun renv::init() in your console to initialize a new project-local environment with a private R library and click yes to the prompt.\nChange the title of your site in index.qmd. After you’ve done some work on your code take a snapshot with renv::snapshot()\nRun .libPaths() and lapply(.libPaths(), list.files)again. What has changed?\nRecreate your environment when collaborating or coming back to your work with renv::restore()\n\n\n\n\n\n(Optional) Learning how to use all the power of Quarto is beyond the scope of this workshop but you can use the below resources to pla around with difference templates and designs for your new website.\n\n\n\nhttps://rstudio-conf-2022.github.io/get-started-quarto/materials/06-websites.html#/websites\nhttps://quarto.org/docs/gallery/#websites\nhttps://quarto.org/docs/websites/website-blog.html#themes\nhttps://www.marvinschmitt.com/blog/website-tutorial-quarto/\nhttps://quarto.org/docs/websites/#workflow"
  },
  {
    "objectID": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html#part-3-version-control-and-authentication-with-github",
    "href": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html#part-3-version-control-and-authentication-with-github",
    "title": "Lab: Deploy Quarto with GHA",
    "section": "Part 3: Version Control and Authentication with Github",
    "text": "Part 3: Version Control and Authentication with Github\n\nWe will need to securely authenticate from our server environment to the server that lives on Github. You can do this via two different authentication mechanisms - SSH or HTTPS. Note that there are two urls created for your repo on github- one is for https and the other is for SSH.\n\n\nHTTPSSSH\n\n\nAuthentication:\n\nCopy the https repository URL that you created.\nCreate a classic personal access token and give it permissions to your repository for “repo”, “user”, and “workflow”. Make sure to note your token somewhere safe.\nInstall usethis with install.packages(\"usethis\")\nSave your PAT with\ngitcreds::gitcreds_set()\n\nVersion Control:\n\nAdd your files to local version control with git add . in the terminal.\nCommit your files with git commit -m \"my first commit\"\nUsing the https url from github add your github repository as the “remote” with git remote add origin https://github.com/username/repo_name.git\nPush your local files to github with git push -u origin main where main is the name of your branch in github. You will be prompted for a username and password. Enter your github username and the personal access token from above as your password.\n\nResources: https://docs.github.com/en/migrations/importing-source-code/using-the-command-line-to-import-source-code/adding-locally-hosted-code-to-github\n\n\nAuthentication:\n\nCopy the SSH repository URL that you created.\nGenerate a new SSH key on your server - open the terminal tab in your Rstudio Workbench environment and type ssh-keygen -t ed25519 -C \"your_github_email@example.com\" . Press enter 3 times to leave the file path as the default and to leave the passphrase blank.\nStart the ssh-agent with eval \"$(ssh-agent -s)\". The ssh-agent is a key manager for SSH. It holds your keys and certificates in memory, un-encrypted, and ready for use by ssh.\nCreate a new hidden file (dot files and directories are hidden but you can see them with ls -la) with touch ~/.ssh/config .\nEdit the file using vi or vim and then add your SSH private key to the ssh-agent. Use the cheat sheet below for common vim commands.\n\nvim touch ~/.ssh/config\ni # to get into insert mode\nHost github.com\n  IgnoreUnknown UseKeychain\n  AddKeysToAgent yes\n  UseKeychain yes\n  IdentityFile ~/.ssh/id_ed25519\n# Press the escape key to exit insert mode\n:wq # to save and exit out of the file\nssh-add ~/.ssh/id_ed25519\n\nCopy your public key with cat ~/.ssh/id_ed25519.pub\nIn your Github account go to Settings &gt; SSH and GPG Keys, and add your SSH key. Give it a name like “workbench key.”\n\nVersion Control:\n\nAdd your files to local version control with git add .\nCommit your files with git commit -m \"my first commit\"\nUsing the https url from github add your github repository as the “remote” with git remote add origin git@github.com:username/repo_name.git\nPush your local files to github with git push -u origin main where main is the name of your branch in github. Type yes to add github to your list of known hosts.\n\nResources\n\nhttps://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\nhttps://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account?platform=linux\nVim Commands Cheat Sheet\n\n\n\n\n\n\n\n\n\n\nGithub CLI\n\n\n\nTo learn more about the Github CLI and the gh package please check out this article."
  },
  {
    "objectID": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html#part-4-publish-using-gha",
    "href": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html#part-4-publish-using-gha",
    "title": "Lab: Deploy Quarto with GHA",
    "section": "Part 4: Publish using GHA",
    "text": "Part 4: Publish using GHA\n\nWe need to create a gh-pages branch to publish to github pages.\n\ngit status # - make sure everything is committed\ngit checkout --orphan gh-pages\ngit reset --hard # make sure you've committed changes before running this!\ngit commit --allow-empty -m \"Initialising gh-pages branch\"\ngit push origin gh-pages\ngit checkout main\n\nGo to Settings &gt; Pages in your github repository and make sure that your site is being built from the gh-pages branch.\n\n\n\nIn your terminal run quarto publish gh-pages and click Yes to the prompt to update the site.\nYour site should now be live!\nCreate a github action called publish.yaml and save it in .github/workflows:\n\nmkdir .github\ncd .github\nmkdir workflows\ncd workflows\ntouch publish.yaml\n\nEdit the publish.yaml file:\n\nname: Deploy quarto site to Github Pages\n\non:\n  workflow_dispatch:\n  push:\n    branches: ['main']\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v4\n\n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n\n      - name: Install R\n        uses: r-lib/actions/setup-r@v2\n        with:\n          r-version: '4.2.3'\n          use-public-rspm: true\n\n      - name: Setup renv and install packages\n        uses: r-lib/actions/setup-renv@v2\n        with:\n          cache-version: 1\n        env:\n          RENV_CONFIG_REPOS_OVERRIDE: https://packagemanager.rstudio.com/all/latest\n\n      - name: Render and Publish\n        uses: quarto-dev/quarto-actions/publish@v2\n        with:\n          target: gh-pages\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\nSnapshot your renv environment with renv::snapshot.\nCommit and push your code: (Make sure that your renv.lock file has been added!)\n\ngit add .\ngit commit -m \"created action\"\ngit push\n\nGo to the actions tab in your Github repository and watch your deploy!"
  },
  {
    "objectID": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html#part-5-publish-to-connect-with-gha",
    "href": "coursework_labs/01_lab_devops_CICD/Deploy_Quarto_GHA.html#part-5-publish-to-connect-with-gha",
    "title": "Lab: Deploy Quarto with GHA",
    "section": "Part 5: Publish to Connect with GHA",
    "text": "Part 5: Publish to Connect with GHA\n\nCreate an API key on the Connect website. Note this API somewhere safe as you will be using it multiple times in the workshop.\n\n\n\nAdd the Connect URL and your API key to your repository:\n\n\nIn your repository go to Settings &gt; Security &gt; Secrets and variables &gt; Actions\nAdd 2 secrets:\n\n\n\nThe rsconnect package needs to be explicitly called in your code to be correctly snapshot in your lock file. Install it and call it in one of your .qmd files.\n\ninstall.packages(\"rsconnect\")\nlibrary(rsconnect)\nrenv::snapshot()\n\nEdit your publish.yaml file:\n\n---\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\nname: Quarto and Connect Publish\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v4\n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n      - name: Install R\n        uses: r-lib/actions/setup-r@v2\n        with:\n          r-version: 4.2.3\n          use-public-rspm: true\n      - name: Setup renv and install packages\n        uses: r-lib/actions/setup-renv@v2\n        with:\n          cache-version: 1\n        env:\n          RENV_CONFIG_REPOS_OVERRIDE: https://packagemanager.rstudio.com/all/latest\n      - name: Render and Publish\n        uses: quarto-dev/quarto-actions/publish@v2\n        with:\n          target: gh-pages\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n  test-and-connect-publish:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n          \n      - name: Remove `.Rprofile`\n        shell: bash\n        run: |\n          rm .Rprofile\n          \n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n\n      - uses: r-lib/actions/setup-r@v2\n        with:\n          r-version: 4.2.3\n          use-public-rspm: true\n          \n      - uses: r-lib/actions/setup-renv@v2\n      - name: Create manifest.json\n        shell: Rscript {0}\n        run: |\n          rsconnect::writeManifest()\n          \n      - name: Publish Connect content\n        uses: rstudio/actions/connect-publish@main\n        with:\n          url: ${{ secrets.CONNECT_SERVER }}\n          api-key: ${{ secrets.CONNECT_API_KEY }}\n          access-type: logged_in\n          dir: |\n            .:/github-actions"
  },
  {
    "objectID": "coursework_labs/03_lab_data_in_prod/lab_solution.html#setup",
    "href": "coursework_labs/03_lab_data_in_prod/lab_solution.html#setup",
    "title": "Lab: Data in Production",
    "section": "Setup",
    "text": "Setup\nTo setup your cloud-based development environment create an account using your email at http://rstd.io/class with code angry-beaver. Click on the Rstudio Connect widget to start your environment."
  },
  {
    "objectID": "coursework_labs/03_lab_data_in_prod/lab_solution.html#part-1-host-api-on-posit-connect",
    "href": "coursework_labs/03_lab_data_in_prod/lab_solution.html#part-1-host-api-on-posit-connect",
    "title": "Lab: Data in Production",
    "section": "Part 1: Host API on Posit Connect",
    "text": "Part 1: Host API on Posit Connect\n\nGo to the Solutions Engineering R-examples repo and copy the HTTPS url.\nIn Connect click Publish and Import from Git. Enter the URL that you copied above and click Next.\nSelect the main branch and click next.\nSelect the plumber-penguins/app directory and give it a name.\nClick `Deploy Content. In a few moments your API should be live!"
  },
  {
    "objectID": "coursework_labs/03_lab_data_in_prod/lab_solution.html#part-2-explore-your-api",
    "href": "coursework_labs/03_lab_data_in_prod/lab_solution.html#part-2-explore-your-api",
    "title": "Lab: Data in Production",
    "section": "Part 2: Explore your API",
    "text": "Part 2: Explore your API\n\nExplore the endpoints for the API. Click the GET for each endpoint and then click Try it out and Execute.\nClick on the link ending in openapi.json below the title of you API.\n\n\n\nTry accessing the API via the terminal with curl &lt;URL&gt;. You should receive output that the app is not authorized!\nAuthorize the app for everyone by changing the Access &gt; Sharing option to Anyone - no login required and then try the curl command again. It should work now!\n\n\n\nTry out the /penguins endpoint and grab the Request URL.\nAccess the /penguins endpoint and provide input for the sample size in your terminal and in the app itself.\n\ncurl \"&lt;REQUEST URL&gt;/penguins?sample_size=5\""
  },
  {
    "objectID": "coursework_labs/03_lab_data_in_prod/lab_solution.html#part-3-plumber-examples",
    "href": "coursework_labs/03_lab_data_in_prod/lab_solution.html#part-3-plumber-examples",
    "title": "Lab: Data in Production",
    "section": "Part 3: Plumber Examples",
    "text": "Part 3: Plumber Examples\n\nInstall the plumber examples package. remotes::install_github(\"sol-eng/plumberExamples\")\nRun available_apis to see plumber examples in the package.\nAccess examples and code:\n\nlibrary(plumber)\nplumb_api(package = \"plumberExamples\", name = \"00-hello\") %&gt;% pr_run()"
  },
  {
    "objectID": "coursework_labs/03_lab_data_in_prod/lab_solution.html#part-4-push-button-deployment",
    "href": "coursework_labs/03_lab_data_in_prod/lab_solution.html#part-4-push-button-deployment",
    "title": "Lab: Data in Production",
    "section": "Part 4: Push-button deployment",
    "text": "Part 4: Push-button deployment\n\nPublish the 11-car-inventory example to Connect.\nClick the blue publishing icon in the upper right of the file editor.\n\n\n\nWhen prompted connect to the Posit Connect server with the provided url. Click Publish."
  },
  {
    "objectID": "coursework_labs/03_lab_data_in_prod/lab_solution.html#part-5-programmatically-access-connect",
    "href": "coursework_labs/03_lab_data_in_prod/lab_solution.html#part-5-programmatically-access-connect",
    "title": "Lab: Data in Production",
    "section": "Part 5: Programmatically access Connect",
    "text": "Part 5: Programmatically access Connect\n\nWe want to programmatically identify all the content that has been published. You will need to use the Connect API Key that you created in the earlier lab. Or you can create a new key.\n\n\n\nOpen a new R script In your workbench console. Add your Connect information:\n\n# Add server\nrsconnect::addServer(\n  url = \"https://liberal-bullfinch.74633.fleeting.rstd.io/rsconnect/__api__\",\n  name = \"colorado\"\n)\n\n# Add account\nrsconnect::connectApiUser(\n  account = \"\",\n  server = \"colorado\",\n  apiKey = Sys.getenv(\"CONNECT_API_KEY\"),\n)\n\nAccess your content programmatically in R: - need to add key ias env variable\n\nlibrary(httr)\nlibrary(tidyr)\n\n# Use the /v1/content endpoint to retrieve the full list of content items\nresult &lt;- GET(\n  paste0(Sys.getenv(\"CONNECT_SERVER\"),\"__api__/v1/content\"),\n    add_headers(Authorization = paste(\"Key\", Sys.getenv(\"CONNECT_API_KEY\"))))\n\n# Create a tibble for the content list result response\ndf_full &lt;- unnest_wider(tibble::tibble(dat = content(result)), dat) \n\nAccess your content programmatically in the terminal using curl:\n\nexport CONNECT_API_KEY=XXX\nexport CONNECT_SERVER=https://liberal-bullfinch.74633.fleeting.rstd.io/rsconnect/\n\ncurl --silent --show-error -L --max-redirs 0 --fail \\\n    -H \"Authorization: Key ${CONNECT_API_KEY}\" \\\n    \"${CONNECT_SERVER}__api__/v1/content\""
  }
]